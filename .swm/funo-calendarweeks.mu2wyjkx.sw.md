---
id: mu2wyjkx
title: FunÃ§Ã£o calendarWeeks
file_version: 1.1.3
app_version: 1.18.21
---

useMemo aqui Ã© usado por se tratar se uma funÃ§Ã£o com calculo custoso. todo vez que o componente for renderizado, ela sÃ³ serÃ¡ executada quando necessÃ¡ria.

<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->

### ğŸ“„ src/components/Calendar/index.tsx

```tsx
48       const calendarWeeks = useMemo(() => {
49         const daysInMonthArray = Array.from({
50           length: currentDate.daysInMonth(),
51         }).map((_, i) => {
52           return currentDate.date(i + 1)
53         })
54
55         const firstWeekDays = currentDate.get('day') // ira pegar o nÃºmero do dia e nÃ£o o dio da semana
56
57         const previousMonthFillArray = Array.from({
58           length: firstWeekDays,
59         })
60           .map((_, i) => {
61             return currentDate.subtract(i + 1, 'day')
62           })
63           .reverse()
64
65         const lastDayInCurrentMonth = currentDate.set(
66           'date',
67           currentDate.daysInMonth() // pego o Ãºltimo dia do mÃªs
68         )
69
70         const lastWeekDay = lastDayInCurrentMonth.get('day')
71
72         const nextMonthFillArray = Array.from({
73           length: 7 - (lastWeekDay + 1),
74         }).map((_, i) => {
75           return lastDayInCurrentMonth.add(i + 1, 'day')
76         })
77
78         // return nextMonthFillArray
```

<br/>

O hook `useMemo` Ã© utilizado para memorizar o valor calculado de uma funÃ§Ã£o, de forma que essa funÃ§Ã£o sÃ³ serÃ¡ reexecutada quando uma das suas dependÃªncias mudar. Isso Ã© Ãºtil para otimizar o desempenho, evitando cÃ¡lculos desnecessÃ¡rios em cada renderizaÃ§Ã£o do componente.

No seu caso, a funÃ§Ã£o `useMemo` estÃ¡ sendo usada para calcular as semanas do calendÃ¡rio com base na data atual (`currentDate`). Aqui estÃ¡ o que cada parte do cÃ³digo faz:

- `const calendarWeeks = useMemo(...)`: DeclaraÃ§Ã£o de uma constante chamada `calendarWeeks` que irÃ¡ armazenar o valor retornado pelo `useMemo`.

- `Array.from({ length: currentDate.daysInMonth() })`: Cria um array com um tamanho igual ao nÃºmero de dias do mÃªs atual. Por exemplo, se `currentDate.daysInMonth()` retorna `30`, serÃ¡ criado um array de `30` elementos.

- `.map((_, i) => { return currentDate.date(i + 1) })`: Transforma esse array em um array de datas do mÃªs atual. O mÃ©todo `map` Ã© usado para iterar sobre cada elemento do array (que inicialmente nÃ£o contÃ©m valores Ãºteis, apenas "slots" vazios). O parÃ¢metro `_` Ã© ignorado (Ã© uma convenÃ§Ã£o para indicar que o parÃ¢metro nÃ£o serÃ¡ usado), e o `i` Ã© o Ã­ndice do elemento atual no array. Para cada elemento, Ã© retornada uma nova data (`currentDate.date(i + 1)`) que representa cada dia do mÃªs.

- O segundo argumento do `useMemo`, `[currentDate]`, Ã© um array de dependÃªncias. Isso significa que o cÃ¡lculo das semanas do calendÃ¡rio sÃ³ serÃ¡ refeito quando o valor de `currentDate` mudar. Se `currentDate` permanecer o mesmo, o `useMemo` irÃ¡ retornar o valor memorizado, sem necessidade de recalcular as datas.

Resumindo, o `useMemo` nesse exemplo Ã© utilizado para calcular as datas de cada dia do mÃªs atual e garantir que esse cÃ¡lculo sÃ³ seja feito quando a data atual (`currentDate`) mudar, o que pode melhorar o desempenho se o cÃ¡lculo for pesado ou se for utilizado em um componente que renderiza frequentemente.<br/>

<br/>

Preencher com os dias do mÃªs anterior atÃ© completar a semana.

<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->

### ğŸ“„ src/components/Calendar/index.tsx

```tsx
55         const firstWeekDays = currentDate.get('day') // ira pegar o nÃºmero do dia e nÃ£o o dio da semana
56
57         const previousMonthFillArray = Array.from({
58           length: firstWeekDays,
59         })
60           .map((_, i) => {
61             return currentDate.subtract(i + 1, 'day')
62           })
63           .reverse()
64
65         const lastDayInCurrentMonth = currentDate.set(
66           'date',
67           currentDate.daysInMonth() // pego o Ãºltimo dia do mÃªs
68         )
69
70         const lastWeekDay = lastDayInCurrentMonth.get('day')
71
72         const nextMonthFillArray = Array.from({
73           length: 7 - (lastWeekDay + 1),
74         }).map((_, i) => {
75           return lastDayInCurrentMonth.add(i + 1, 'day')
76         })
77
78         // return nextMonthFillArray
```

<br/>

<br/>

1.  `firstDayOfMonthWeekday` pega o dia da semana do primeiro dia do mÃªs (0 para domingo, 1 para segunda-feira, etc.).

2.  `const previousMonthFillArray`: Este array Ã© criado para conter os dias do mÃªs anterior que preenchem a primeira semana do mÃªs atual. Por exemplo, se o mÃªs atual comeÃ§a numa quarta-feira, `firstWeekDays` seria 3 (considerando que domingo Ã© o dia 0), e vocÃª quer os Ãºltimos dois dias do mÃªs anterior para preencher domingo e segunda.

3.  `.map((_, i) => { return currentDate.subtract(i + 1, 'day') })`: Para cada elemento do array `previousMonthFillArray`, vocÃª estÃ¡ subtraindo dias da `currentDate` para obter os dias do mÃªs anterior. EntÃ£o, se hoje Ã© 1 de abril e uma quarta-feira, vocÃª irÃ¡ subtrair 1 dia para terÃ§a-feira, 31 de marÃ§o, e assim por diante.

4.  `return { ...previousMonthFillArray, ...daysInMonthArray }`: Esta linha estÃ¡ tentando espalhar (usando o spread operator `...`) os elementos dos dois arrays em um objeto, o que nÃ£o Ã© correto se vocÃª deseja um array Ãºnico. Para concatenar dois arrays, vocÃª deveria usar `[...previousMonthFillArray, ...daysInMonthArray]`<br/>

    ```
    <br/>
    ```

    <br/>

<br/>

Quantos dias vou precisar do prÃ³ximo mÃªs

<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->

### ğŸ“„ src/components/Calendar/index.tsx

```tsx
70         const lastDayInCurrentMonth = currentDate.set(
71           'date',
72           currentDate.daysInMonth() // pego o Ãºltimo dia do mÃªs
73         )
74
75         const lastWeekDay = lastDayInCurrentMonth.get('day')
76
77         const nextMonthFillArray = Array.from({
78           length: 7 - (lastWeekDay + 1),
79         }).map((_, i) => {
80           return lastDayInCurrentMonth.add(i + 1, 'day')
81         })
82
83         // return nextMonthFillArray
84         const calendarDays = [
85           ...previousMonthFillArray.map((date) => {
86             return { date, disabled: true }
87           }),
88           ...daysInMonthArray.map((date) => {
89             return { date, disabled: date.endOf('day').isBefore(new Date()) }
90           }),
91           ...nextMonthFillArray.map((date) => {
92             return { date, disabled: true }
93           }),
94         ]
```

<br/>

<br/>

1.  **Definindo o Ãºltimo dia do mÃªs corrente:**

    ```
    javascriptCopy code
    ```

    `const lastDayInCurrentMonth = currentDate.set('date', currentDate.daysInMonth())`

    Aqui, estamos usando a biblioteca `dayjs` para definir uma nova data (`lastDayInCurrentMonth`) que representa o Ãºltimo dia do mÃªs atual. O mÃ©todo `daysInMonth()` retorna o nÃºmero total de dias no mÃªs corrente, e o mÃ©todo `set('date', value)` estÃ¡ sendo utilizado para definir o dia do objeto `currentDate` para esse valor. Em outras palavras, estamos criando uma nova data que Ã© o Ãºltimo dia do mÃªs corrente.

2.  **Obtendo o dia da semana do Ãºltimo dia do mÃªs:**

    ```
    javascriptCopy code
    ```

    `const lastWeekDay = lastDayInCurrentMonth.get('day')`

    Depois de ter a data do Ãºltimo dia do mÃªs, utilizamos o mÃ©todo `get('day')` para descobrir o dia da semana desse Ãºltimo dia. Em `dayjs`, `get('day')` retorna um nÃºmero de 0 (domingo) a 6 (sÃ¡bado), indicando o dia da semana.

3.  **Calculando quantos dias precisamos adicionar para preencher a Ãºltima semana:**

    ```
    javascriptCopy code
    ```

    `const nextMonthFillArray = Array.from({ length: 7 - (lastWeekDay + 1), }).map((_, i) => { return lastDayInCurrentMonth.add(i + 1, 'day') })`

    Aqui, o objetivo Ã© descobrir quantos dias do prÃ³ximo mÃªs precisamos adicionar para completar a semana no calendÃ¡rio. Se o Ãºltimo dia do mÃªs Ã© uma quarta-feira (representado pelo nÃºmero 3), entÃ£o precisamos adicionar mais 3 dias (quinta-feira, sexta-feira e sÃ¡bado) para completar a semana, que tem 7 dias. A expressÃ£o `7 - (lastWeekDay + 1)` faz exatamente esse cÃ¡lculo.

    - Usamos `lastWeekDay + 1` porque, se o `lastWeekDay` Ã© 3 (quarta-feira), precisamos comeÃ§ar a contar a partir de quinta-feira, que seria o dia 4 da semana.

    - SubtraÃ­mos esse valor de 7 (nÃºmero total de dias em uma semana) para encontrar quantos dias faltam.

    - Criamos um array com esse comprimento e usamos `map` para criar uma nova data para cada um desses dias, comeÃ§ando do dia seguinte ao Ãºltimo dia do mÃªs (`lastDayInCurrentMonth.add(i + 1, 'day')`).

4.  **Construindo o array final para o calendÃ¡rio:**

    ```javascript
    javascriptCopy code
    ```

    `return [ ...previousMonthFillArray, ...daysInMonthArray, ...nextMonthFillArray, ]`

    O array final que estamos retornando Ã© uma combinaÃ§Ã£o de trÃªs arrays:

    - `previousMonthFillArray`: Dias do mÃªs anterior para preencher a primeira semana do calendÃ¡rio.

    - `daysInMonthArray`: Todos os dias do mÃªs corrente.

    - `nextMonthFillArray`: Dias do prÃ³ximo mÃªs para completar a Ãºltima semana do calendÃ¡rio.

<br/>

transformar um array de dias (`calendarDays`) em um array de semanas (`calendarWeeks`). Cada semana Ã© um objeto que contÃ©m o nÃºmero da semana (`week`) e os dias que pertencem a essa semana (`days`).

<!-- NOTE-swimm-snippet: the lines below link your snippet to Swimm -->

### ğŸ“„ src/components/Calendar/index.tsx

```tsx
91         const calendarWeeks = calendarDays.reduce<CalendarWeeks>(
92           (weeks, _, i, original) => {
93             const isNewWeek = i % 7 === 0
94
95             if (isNewWeek) {
96               weeks.push({
97                 week: i / 7 + 1,
98                 days: original.slice(i, i + 7),
99               })
100            }
101
102            return weeks
103          },
104          []
105        )
106
107        return calendarWeeks
```

<br/>

<br/>

1.  **DefiniÃ§Ã£o da funÃ§Ã£o** `reduce`**:**

    ```
    javascriptCopy code
    ```

    `const calendarWeeks = calendarDays.reduce<CalendarWeeks>( (weeks, _, i, original) => { // ... }, [] )`

    - `calendarDays`: Ã© o array original que contÃ©m todos os dias que queremos agrupar em semanas.

    - `reduce<CalendarWeeks>`: estÃ¡ definindo o tipo de dado que a funÃ§Ã£o `reduce` irÃ¡ acumular e retornar, neste caso, um array de objetos onde cada objeto representa uma semana.

    - A funÃ§Ã£o `reduce` recebe dois parÃ¢metros: um callback e um valor inicial para o acumulador (`[]` neste caso).

2.  **Callback da funÃ§Ã£o** `reduce`**:**

    ```
    javascriptCopy code
    ```

    `(weeks, _, i, original) => { // ... }`

    - O callback do `reduce` Ã© chamado para cada item do array `calendarDays`.

    - `weeks` Ã© o acumulador, que comeÃ§a como um array vazio `[]` e gradualmente Ã© preenchido com os objetos semana.

    - `_` Ã© o elemento atual do array que estÃ¡ sendo processado. Como ele nÃ£o Ã© usado no corpo da funÃ§Ã£o, foi substituÃ­do por um underscore para indicar que Ã© um parÃ¢metro nÃ£o utilizado.

    - `i` Ã© o Ã­ndice do elemento atual do array.

    - `original` Ã© o array original `calendarDays` que estÃ¡ sendo reduzido.

3.  **VerificaÃ§Ã£o se um novo objeto semana deve ser criado:**

    ```
    javascriptCopy code
    ```

    `const isNewWeek = i % 7 === 0`

    - `isNewWeek` Ã© uma constante booleana que verifica se o Ã­ndice atual Ã© mÃºltiplo de 7, indicando o inÃ­cio de uma nova semana no calendÃ¡rio.

4.  **CriaÃ§Ã£o do objeto semana:**

    ```
    javascriptCopy code
    ```

    `if (isNewWeek) { weeks.push({ week: i / 7 + 1, days: original.slice(i, i + 7), }) }`

    - Se `isNewWeek` for `true`, um novo objeto Ã© criado e adicionado ao array `weeks`.

    - `week: i / 7 + 1` calcula o nÃºmero da semana atual baseando-se no Ã­ndice do dia no array original. Como o Ã­ndice comeÃ§a em 0, `i / 7` retorna um nÃºmero a menos do que o nÃºmero real da semana, entÃ£o adicionamos 1 para corrigir isso.

    - `days: original.slice(i, i + 7)` cria um subarray de `original` contendo os 7 dias da semana atual.

5.  **Retorno do acumulador:**

    ```
    javascriptCopy code
    ```

    `return weeks`

    - ApÃ³s cada iteraÃ§Ã£o, o acumulador `weeks` Ã© retornado e passado para a prÃ³xima iteraÃ§Ã£o do `reduce`.

Ao final do processo, `calendarWeeks` serÃ¡ um array onde cada item Ã© um objeto representando uma semana do calendÃ¡rio, contendo o nÃºmero da semana e os dias pertencentes a essa semana.

<br/>

This file was generated by Swimm. [Click here to view it in the app](https://app.swimm.io/repos/Z2l0aHViJTNBJTNBaWduaXRlLTIwMjIlM0ElM0FkeWphcnVmYQ==/docs/mu2wyjkx).
